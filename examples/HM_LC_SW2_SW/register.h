//- ----------------------------------------------------------------------------------------------------------------------
//- load libraries -------------------------------------------------------------------------------------------------------
#include <AS.h>                                                         // the asksin framework
#include "hardware.h"                                                   // hardware definition
#include <cmSwitch.h>

//- stage modules --------------------------------------------------------------------------------------------------------
AS hm;                                                                  // asksin framework

cmSwitch cmSwitch[2];                                                 // create instances of channel module
extern void initRly(uint8_t channel);                                   // declare function to jump in
extern void switchRly(uint8_t channel, uint8_t status);                 // declare function to jump in

//- ----------------------------------------------------------------------------------------------------------------------
//- eeprom defaults table ------------------------------------------------------------------------------------------------
uint16_t EEMEM eMagicByte;
uint8_t  EEMEM eHMID[3]  = {0x0a,0x13,0x01};
uint8_t  EEMEM eHMSR[10] = {'H','M','R','y','1','0','0','0','0','1'};
uint8_t  EEMEM eHMKEY[16] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,};

// if HMID and Serial are not set, then eeprom ones will be used
uint8_t HMID[3] = {0x0a,0x13,0x01};
uint8_t HMSR[10] = {'H','M','R','y','1','0','0','0','0','1'};
uint8_t HMKEY[16] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,};

//- ----------------------------------------------------------------------------------------------------------------------
//- generated by createRegisterFromFile.pl
//- ID: 0x0066, File: rf_s.xml
//- ----------------------------------------------------------------------------------------------------------------------

//- ----------------------------------------------------------------------------------------------------------------------
//- ----------------------------------------------------------------------------------------------------------------------
//                                   FW  moID   serial                         ST  devInfo
// <- 1A 01 A4 00 01 02 05 63 19 63  15  00 6C  74 6C 75 31 30 30 31 32 33 35  10  11 01 00
// FW   -> Firmware, sometimes given in xml files of hm config software
// moID -> Model ID, important for identification in hm config software
// ST   -> Subtype, identifier if device is a switch or a dimmer or a remote
// devInfo -> Device Info -> sometimes hm config files are refering on byte 23 for the amount of channels, other bytes not known
//                           23:0 0.4, means first four bit of byte 23 reflecting the amount of channels
//
//- settings of HM device for AS class -----------------------------------------------------------------------------------
const uint8_t devIdnt[] PROGMEM = {
    /* Firmware version 1 byte */  0x16,
    /* Model ID         2 byte */  0x00, 0x0a,
    /* Sub Type ID      1 byte */  0x00,
    /* Device Info      3 byte */  0x41, 0x01, 0x00,
};

//- ----------------------------------------------------------------------------------------------------------------------
//- channel slice address definition -------------------------------------------------------------------------------------
const uint8_t cnlAddr[] PROGMEM = {
    0x02, 0x0a, 0x0b, 0x0c,
    0x08, 0x30, 0x56, 0x57,
    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c,
};  // 30 byte

//- channel device list table --------------------------------------------------------------------------------------------
EE::s_cnlTbl cnlTbl[] = {
  // cnl, lst, sIdx, sLen, pAddr;
    {  0,  0, 0x00,  4,  0x0020, 0, },
    {  1,  1, 0x04,  4,  0x0024, 0, },
    {  1,  3, 0x08, 22,  0x0028, 0, },
    {  2,  1, 0x04,  4,  0x0054, 0, },
    {  2,  3, 0x08, 22,  0x0058, 0, },
}; 

//- peer device list table -----------------------------------------------------------------------------------------------
EE::s_peerTbl peerTbl[] = {
    // cnl, pMax, pAddr;
    {  1,  2, 0x00e4 },
    {  2,  2, 0x00ec },
}; 

//- handover to AskSin lib -----------------------------------------------------------------------------------------------
EE::s_devDef devDef = {
    2, 5, devIdnt, cnlAddr,
};  // 10 byte

//- module registrar -----------------------------------------------------------------------------------------------------
RG::s_modTable modTbl[2];

//- ----------------------------------------------------------------------------------------------------------------------
//- first time and regular start functions -------------------------------------------------------------------------------

void everyTimeStart(void) {
  // calculate tables
/*
  EE::s_cnlTbl* ptr = cnlTbl;
  uint16_t addr = ptr->pAddr;
  for( int i=0; i<devDef.lstNbr; ++i ) {
    dbg.println(addr,HEX);
    if( ptr[i].lst < 2 ) {
      addr += ptr->sLen;
    }
    else {
      addr += (ptr[i].sLen * peerTbl[ptr[i].cnl-1].pMax);
    }
  }
  for( int i=0; i<devDef.cnlNbr; ++i ) {
    dbg.println(addr,HEX);
    addr += (peerTbl[i].pMax * 4);
  }
*/  
    
  
	// place here everything which should be done on each start or reset of the device
	// typical use case are loading default values or user class configurations

	// init the homematic framework
	hm.confButton.config(1, CONFIG_KEY_PCIE, CONFIG_KEY_INT);           // configure the config button, mode, pci byte and pci bit
	hm.ld.init(1, &hm);                                                 // set the led
	hm.ld.set(welcome);                                                 // show something
	hm.bt.set(0,0); // disable 30, 3600000);                                             // set battery check, internal, 2.7 reference, measurement each hour
	hm.pw.setMode(0);                                                   // set power management mode

    // register user modules
    cmSwitch[0].regInHM(1, 3, &hm);                                    // register user module
    cmSwitch[0].config(&initRly, &switchRly);                          // configure user module

    cmSwitch[1].regInHM(2, 3, &hm);                                    // register user module
    cmSwitch[1].config(&initRly, &switchRly);                          // configure user module
}

void firstTimeStart(void) {
	// place here everything which should be done on the first start or after a complete reset of the sketch
	// typical use case are default values which should be written into the register or peer database

}
